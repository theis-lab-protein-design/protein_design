import subprocess
import hydra
import re
from tqdm import tqdm as standard_tqdm
import os
import pandas as pd
import torch
import biotite.structure.io as bsio
import torch
import numpy
from utils.cleanup_fasta import parse_and_extract as cleanup_fasta_parse_and_extract
from utils.create_empty_msa import main as create_empty_msa_main


def print_gpu_info():
    """
    Convenience function.
    Prints information about the GPU(s) available to PyTorch, including CUDA availability, version, number of GPUs, and details for each GPU such as name, compute capability, and total memory.
    """
    # Check if CUDA is available
    use_cuda = torch.cuda.is_available()
    print(f"CUDA available: {use_cuda}")

    if use_cuda:
        # Get CUDA version
        print(f"CUDA version: {torch.version.cuda}")
        
        # Get number of available GPUs
        num_gpus = torch.cuda.device_count()
        print(f"Number of GPUs: {num_gpus}")
        
        # Get details of each GPU
        for i in range(num_gpus):
            print(f"\nGPU {i}:")
            print(f"  Name: {torch.cuda.get_device_name(i)}")
            
            # Get GPU compute capability
            compute_capability = torch.cuda.get_device_capability(i)
            print(f"  Compute capability: {compute_capability[0]}.{compute_capability[1]}")
            
            # Get GPU total memory
            total_memory = torch.cuda.get_device_properties(i).total_memory
            print(f"  Total memory: {total_memory / (1024 ** 3):.2f} GB")


try:
    from tqdm.notebook import tqdm as notebook_tqdm
except ImportError:
    notebook_tqdm = None

def get_tqdm():
    try:
        get_ipython
        if 'IPKernelApp' not in get_ipython().config:  # Check if not in IPython
            raise NameError("Not in IPython")
        return notebook_tqdm if notebook_tqdm else standard_tqdm
    except NameError:
        return standard_tqdm


def run_diffusion(output_prefix: str, total_steps=50, symmetry : str = "c8"):
    """
    Runs a diffusion process to generate a C8 symmetric ogliomer.

    Args:
    output_prefix (str): The prefix for the output files generated by the diffusion process. E.g. if prefix is output/rf_diffusion, the function will create files such as output/rf_diffusion_0.pdb
    total_steps (int, optional): The total number of diffusion steps to perform. Defaults to 50. 

    Raises:
    ValueError: If no output_prefix is provided.
    """
    tqdm = get_tqdm()
    if not output_prefix:
        raise ValueError("output_prefix must be provided")
    process = subprocess.Popen([
        "python", "./modules/RFdiffusion/scripts/run_inference.py",
        "--config-name", "symmetry",
        f"inference.symmetry={symmetry}",
        "contigmap.contigs=[360-360]",
        f"inference.output_prefix={output_prefix}",
        "inference.num_designs=1",
        f"diffuser.T={total_steps}"
    ])

    process.communicate()

    output_path =  output_prefix + "_0.pdb"
    print("RFDiffusion output can be found at", output_path)
    return output_path

def run_protein_mpnn(input_folder : str, output_folder : str, num_seq_per_target = 10):
    print("Running ProteinMPNN")
    folder_with_pdbs = input_folder
    os.makedirs(output_folder, exist_ok=True)

    path_for_parsed_chains = os.path.join(output_folder, "parsed_pdbs.jsonl")
    path_for_tied_positions = os.path.join(output_folder, "tied_pdbs.jsonl")

    subprocess.run([
        "python", "./modules/ProteinMPNN/helper_scripts/parse_multiple_chains.py",
        "--input_path", folder_with_pdbs,
        "--output_path", path_for_parsed_chains
    ],stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, check=True)

    subprocess.run([
        "python", "./modules/ProteinMPNN/helper_scripts/make_tied_positions_dict.py",
        "--input_path", path_for_parsed_chains,
        "--output_path", path_for_tied_positions,
        "--homooligomer", "1"
    ],stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, check=True)

    subprocess.run([
        "python", "./modules/ProteinMPNN/protein_mpnn_run.py",
        "--jsonl_path", path_for_parsed_chains,
        "--tied_positions_jsonl", path_for_tied_positions,
        "--out_folder", output_folder,
        "--num_seq_per_target", str(num_seq_per_target),
        "--sampling_temp", "0.2",
        "--seed", "37",
        "--batch_size", "1"
    ],stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, check=True)
    print("ProteinMPNN finished, output can be found at", output_folder)


def get_latest_run_path(directory: str) -> str:
    """
    Gets the path of the latest created folder within the specified directory.

    Args:
        directory (str): The directory to search for the latest folder.

    Returns:
        str: The path to the latest created folder.
    """
    all_subdirs = [os.path.join(directory, d) for d in os.listdir(directory) if os.path.isdir(os.path.join(directory, d))]
    latest_subdir = max(all_subdirs, key=os.path.getmtime)
    return latest_subdir


@hydra.main(version_base=None, config_path="../config/inference", config_name="base")
def main():
    run_diffusion()
